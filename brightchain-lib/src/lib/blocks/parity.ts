import { BlockDataType } from '../enumerations/blockDataType';
import { BlockSize } from '../enumerations/blockSizes';
import { BlockType } from '../enumerations/blockType';
import { StaticHelpersChecksum } from '../staticHelpers.checksum';
import { ChecksumBuffer } from '../types';
import { BaseBlock } from './base';
import { RawDataBlock } from './rawData';

/**
 * ParityBlock represents a block containing forward error correction (FEC) data.
 * It is used to recover data when some blocks in a tuple are lost or corrupted.
 * The parity data is generated by XORing all data blocks in a tuple together.
 */
export class ParityBlock extends RawDataBlock {
  constructor(
    blockSize: BlockSize,
    data: Buffer,
    dateCreated?: Date,
    checksum?: ChecksumBuffer,
    canRead = true,
    canPersist = true,
  ) {
    if (data.length !== blockSize) {
      throw new Error('Data length must match block size');
    }

    super(blockSize, data, dateCreated, checksum, canRead, canPersist);
  }

  /**
   * Create a new parity block by XORing multiple blocks together
   */
  public static fromBlocks(blocks: BaseBlock[]): ParityBlock {
    if (!blocks.length) {
      throw new Error('No blocks provided');
    }

    const blockSize = blocks[0].blockSize;
    if (!blocks.every((b) => b.blockSize === blockSize)) {
      throw new Error('All blocks must have the same size');
    }

    // XOR all blocks together
    let result = blocks[0].data;
    for (let i = 1; i < blocks.length; i++) {
      const current = blocks[i].data;
      if (current.length !== result.length) {
        throw new Error('Block sizes must match');
      }

      const xored = Buffer.alloc(result.length);
      for (let j = 0; j < result.length; j++) {
        xored[j] = result[j] ^ current[j];
      }
      result = xored;
    }

    return new ParityBlock(
      blockSize,
      result,
      new Date(),
      StaticHelpersChecksum.calculateChecksum(result),
    );
  }

  /**
   * The type of the block
   */
  public override get blockType(): BlockType {
    return BlockType.FECData;
  }

  /**
   * The type of data in the block
   */
  public override get blockDataType(): BlockDataType {
    return BlockDataType.RawData;
  }

  /**
   * The data in the block, excluding any metadata or other overhead
   */
  public override get payload(): Buffer {
    if (!this.canRead) {
      throw new Error('Block cannot be read');
    }
    // For parity blocks, like raw data blocks, the payload is the entire data
    return this.data;
  }

  /**
   * Whether the block can be encrypted
   */
  public override get canEncrypt(): boolean {
    return false; // Parity blocks cannot be encrypted
  }

  /**
   * Whether the block can be decrypted
   */
  public override get canDecrypt(): boolean {
    return false; // Parity blocks cannot be decrypted
  }

  /**
   * Whether the block can be signed
   */
  public override get canSign(): boolean {
    return false; // Parity blocks cannot be signed
  }

  /**
   * Get this layer's header data
   */
  public override get layerHeaderData(): Buffer {
    // Parity blocks don't have any layer-specific header data
    return Buffer.alloc(0);
  }

  /**
   * Get the complete header data from all layers
   */
  public override get fullHeaderData(): Buffer {
    return Buffer.concat([super.fullHeaderData, this.layerHeaderData]);
  }

  /**
   * Get the usable capacity after accounting for overhead
   */
  public override get capacity(): number {
    return this.blockSize - this.totalOverhead;
  }

  /**
   * XOR this block with another block
   */
  public xor<T extends BaseBlock>(other: T): T {
    if (this.blockSize !== other.blockSize) {
      throw new Error('Block sizes must match');
    }

    const result = Buffer.alloc(this.data.length);
    for (let i = 0; i < this.data.length; i++) {
      result[i] = this.data[i] ^ other.data[i];
    }

    // Create a new instance of the same type as the input block
    const Constructor = other.constructor as new (
      blockSize: BlockSize,
      data: Buffer,
      dateCreated: Date,
      checksum: ChecksumBuffer,
      canRead: boolean,
      canPersist: boolean,
    ) => T;

    return new Constructor(
      this.blockSize,
      result,
      new Date(),
      StaticHelpersChecksum.calculateChecksum(result),
      this.canRead && other.canRead,
      this.canPersist && other.canPersist,
    );
  }
}
