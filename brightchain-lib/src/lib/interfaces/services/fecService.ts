/**
 * @file IFecService interface for Forward Error Correction operations
 * @description Defines the contract for FEC services that provide Reed-Solomon
 * encoding/decoding for block durability and recovery.
 *
 * This interface is implemented by:
 * - WasmFecService (brightchain-api-lib) - Cross-platform WASM implementation
 * - NativeRsFecService (brightchain-api-lib) - Apple Silicon hardware acceleration
 *
 * Uses Uint8Array for browser compatibility (Requirement 18.6).
 *
 * @requirements 1.8, 4.5, 4.6, 4.8
 */

/**
 * Represents parity data generated by FEC encoding
 */
export interface ParityData {
  /** The parity data bytes */
  data: Uint8Array;
  /** The index of this parity shard (0-based) */
  index: number;
}

/**
 * Result of an FEC recovery operation
 */
export interface FecRecoveryResult {
  /** The recovered data */
  data: Uint8Array;
  /** Whether recovery was successful */
  recovered: boolean;
}

/**
 * Interface for Forward Error Correction (FEC) services.
 *
 * FEC services provide Reed-Solomon erasure coding functionality for:
 * 1. Creating parity data for block recovery
 * 2. Recovering corrupted or missing blocks using parity data
 * 3. Verifying block integrity against parity data
 *
 * Multiple implementations may exist for different environments:
 * - Native implementations for hardware acceleration
 * - WASM implementations for cross-platform support
 * - Browser implementations for lightweight usage
 */
export interface IFecService {
  /**
   * Check if this FEC service is available in the current environment.
   *
   * This method should check for:
   * - Required native libraries or WASM modules
   * - Hardware support (e.g., Apple Silicon for native implementations)
   * - Any other environment-specific requirements
   *
   * @returns Promise resolving to true if the service is available
   */
  isAvailable(): Promise<boolean>;

  /**
   * Create parity data for a block using Reed-Solomon encoding.
   *
   * This method generates parity shards that can be used to recover
   * the original data if it becomes corrupted or lost.
   *
   * @param blockData - The original block data to create parity for
   * @param parityCount - Number of parity shards to generate
   * @returns Promise resolving to array of parity data objects
   * @throws FecError if encoding fails or parameters are invalid
   *
   * @example
   * ```typescript
   * const parity = await fecService.createParityData(blockData, 2);
   * // parity[0] and parity[1] can be stored separately for recovery
   * ```
   */
  createParityData(
    blockData: Uint8Array,
    parityCount: number,
  ): Promise<ParityData[]>;

  /**
   * Recover block data using parity data.
   *
   * This method reconstructs the original block data using the
   * available parity shards. Pass null for corruptedData if the
   * original data is completely missing.
   *
   * @param corruptedData - The corrupted block data, or null if completely missing
   * @param parityData - Array of available parity data objects
   * @param originalSize - The original size of the block data in bytes
   * @returns Promise resolving to recovery result with recovered data
   * @throws FecError if recovery fails or insufficient parity data
   *
   * @example
   * ```typescript
   * // Recover completely missing data
   * const result = await fecService.recoverFileData(null, parityData, originalSize);
   * if (result.recovered) {
   *   // Use result.data
   * }
   * ```
   */
  recoverFileData(
    corruptedData: Uint8Array | null,
    parityData: ParityData[],
    originalSize: number,
  ): Promise<FecRecoveryResult>;

  /**
   * Verify block integrity against its parity data.
   *
   * This method regenerates parity data from the block and compares
   * it with the stored parity data to detect corruption.
   *
   * @param blockData - The block data to verify
   * @param parityData - The stored parity data to verify against
   * @returns Promise resolving to true if the block is intact
   *
   * @example
   * ```typescript
   * const isValid = await fecService.verifyFileIntegrity(blockData, parityData);
   * if (!isValid) {
   *   // Block is corrupted, attempt recovery
   * }
   * ```
   */
  verifyFileIntegrity(
    blockData: Uint8Array,
    parityData: ParityData[],
  ): Promise<boolean>;
}
